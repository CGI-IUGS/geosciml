<?xml version="1.0" encoding="UTF-8"?><!--
  Copyright 1999-2004 The Apache Software Foundation

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
--><!--+
    | This is the 'heart' of Cocoon. The sitemap maps URI space to
    | resources. It consists basicaly of two parts: components and
    | pipelines. Pipelines are made out of components. There is such a
    | vast number of components available that it would be impossible to
    | describe them here, please refer to the accompanying
    | documentation. For specific components, have a look also at the
    | javadocs for them. Most pipelines are present to demonstrate some
    | feature or technique, often they are explained in more detail in
    | the accompanying documentation. The sitemaps which come with each
    | sample and each block will help to explain.
    |
    | CVS $Id: sitemap.xmap 389028 2006-03-27 06:21:40Z rgoers $
    +--><map:sitemap xmlns:map="http://apache.org/cocoon/sitemap/1.0">

<!-- =========================== Components ================================ -->
	<map:components>
		<map:generators>
			<map:generator label="content" logger="sitemap.generator.request" name="xmlStream" pool-grow="2" pool-max="16" pool-min="2" src="org.apache.cocoon.generation.XmlStreamGenerator"/>
		</map:generators>
		<map:transformers default="xslt">
			<map:transformer name="DeegreeService" logger="deegree.transformer" src="org.apache.cocoon.transformation.DeegreeService"/>
			<map:transformer name="PostClient" logger="ngwd.transformer" src="org.apache.cocoon.transformation.PostClient"/>
		</map:transformers>
		<map:actions>
		<map:action logger="sitemap.action.xsp-action"
	name="xsp-action"
	src="org.apache.cocoon.acting.ServerPagesAction"/>
		</map:actions>
	</map:components>


<map:pipelines>

<map:component-configurations>
  <global-variables>
  <!-- this is the url of the original wfs -->
  <wfs-host>http://localhost:8888/geosciml/wfs</wfs-host>
      <url-ngwd>http://ngwd-bdnes.cits.rncan.gc.ca/service/iugs/wfs</url-ngwd>
      <url-apat>http://serviziogeologico.apat.it/servlet/com.esri.esrimap.Esrimap?ServiceName=geounit500k&amp;CustomService=Query</url-apat>
  </global-variables>
</map:component-configurations>




  <!-- sub sections -->
<map:pipeline>
	<map:match pattern="res/**">
		<map:read src="res/{1}"/>
	</map:match>
	<map:match pattern="**.js">
		<map:read src="js/{1}.js"/>
	</map:match>
	<map:match pattern="**.html">
		<map:read src="html/{1}.html"/>
	</map:match>
	<map:match pattern="**.gif">
		<map:read src="js/{1}.gif"/>
	</map:match>
	
</map:pipeline>


<map:pipeline>
	<map:match pattern="dev/get">
	<!-- test STX POST trick -->
	<map:generate src="document/ai.xml"/>
	<map:transform type="stx" src="style/post.stx"/>
<map:serialize type="xml"/>
	</map:match>
</map:pipeline>

<!-- GeoSciML/ GWML wrapper engine -->
		<!-- ============================================================= -->
		<!-- ============================================================= -->
		<!-- ============================================================= -->
		<map:pipeline type="noncaching">
		<map:parameter name="outputBufferSize" value="8192"/>
			<!-- INIT SECTION -->
			<map:match pattern="wfs">
				<map:redirect-to uri="cocoon:/wfs/default"/>
			</map:match>
			<map:match pattern="wfs/*">
			<map:act type="xsp-action" src="xsp/set_config.xsp">
			<map:parameter name="config" value="{1}"/>
				<map:select type="request-method">
					<map:when test="GET">
						<!-- REQUEST SUBMITTED IN GET FORMAT, must be translated in POST/XML -->
						<map:generate type="request"/>
						<map:transform type="stx" src="style/analyse_get_request.stx">
							<map:parameter name="config" value="wfs-{../1}"/>
						</map:transform>
						
						<map:transform type="cinclude"/>
						<map:transform type="saxon" src="style/GetToPostWfs.xslt"/>
						<map:transform type="strnode"/>
						<map:transform type="stx" src="style/clean_get_request.stx"/>
					</map:when>
					<map:otherwise>
						<!-- handle POST requests -->
						<map:generate type="xmlStream">
							<map:parameter name="defaultContentType" value="text/xml"/>
						</map:generate>
						<map:transform type="saxon" src="style/addns.xslt"/>
					</map:otherwise>
				</map:select>
				<!-- This section writes a copy of the request in a temps file, and loads the config in memory. -->
				<map:transform src="style/pre-process-job.xslt" type="saxon">
					<map:parameter name="config" value="wfs-{../1}"/>
				</map:transform>
				<map:transform type="write-source"/>
				<map:transform type="cinclude"/>
				  <!--This block turns the query into a job sequence ; a series of calls to the process pipelines-->
				<map:transform src="style/job.xslt" type="saxon"/>
				
				 <!-- the include transformer sends the command to the relevant pipelines -->
				<map:transform type="include">
					<!-- some processors can actually bounce back to another 1..* processor -->
					<map:parameter name="recursive" value="true"/>
				</map:transform>
				<!--<map:transform src="style/extract-query.xslt" type="saxon"/>
				<map:transform src="style/redirectService.stx" type="stx">
					<map:parameter name="requester" value="{request:remoteAddr}"/>
					<map:parameter name="targetService" value="http://s5-stf-ngwd.nrn.nrcan.gc.ca:8080"/>
				</map:transform>
		-->
		<!-- this last transformer extract from data the XML streams that otherwise also contains configurations,commands and results status--> 
				 <map:transform type="stx" src="style/deProc.stx"/>
				<map:serialize type="xml"/>
				</map:act>
			</map:match>
			<!-- END OF INIT SECTION 
		<map:match pattern="wfs-process-GetFeature">
			
		</map:match>-->
		<!-- 
cleans from the temp directory the query document passed in {1} 
invocation:		wfs-process-clean/[key]
-->
			<map:match pattern="wfs-process-clean/*">
				<map:generate type="serverpages" src="xsp/delete_req.xsp">
					<map:parameter name="key" value="q{1}"/>
				</map:generate>
				<map:transform type="write-source"/>
				<map:serialize type="xml"/>
			</map:match>
			<!--
Get a GetFeatureRequest and get only then nth Query node
invocation: wfs-GetRequest/[key]/[n]
-->
			<map:match pattern="wfs-GetRequest/*/*">
			<map:generate src="temp/req_{1}.xml"/>
			<map:transform type="saxon" src="style/subsetQuery.xslt">
				<map:parameter name="pos" value="{2}"/>
			</map:transform>
			<map:serialize type="xml"/>
			</map:match>
			<!-- SPECIFIC OP SECTIONS 
=====================================
=====================================-->
			<map:match pattern="wfs-process-DescribeFeatureType/*/*">
			<!-- TODO: maybe we should get this in the config file ?? -->
				<map:generate src="schemas/Well.xsd"/>
				<map:serialize type="xml"/>
			</map:match>
			
			<map:match pattern="wfs-process-GetCapabilities">
				<!-- we ignore the key for now, since we deal with a static GetCap file.  The capabilities file has been doctored so some part can be replaced , ie, the host location.  But the same principle can be used to automatically replace some other parts dynamically -->
				<map:generate src="capabilities/wfs-{session:config}.xml"/>
				<!-- replaces the [host] placeholders with a host , so the code can be moved from one server to the other -->
				<map:transform src="style/replaceHost.stx" type="stx">
					<map:parameter name="host" value="{global:wfs-host}"/>
				</map:transform>
				<map:serialize type="xml"/>
			</map:match>
			
			<map:match pattern="wfs-process-ExceptionReport/*/*">
				<map:generate src="temp/req_{1}.xml"/>
				<map:serialize type="xml"/>
			</map:match>
			
			<!-- ========================  GET FEATURE PROCESSORS =============== -->
			
<!-- Get feature processor 
There could be as many GetFeature processor as required, they are normally organised by datasource because each datasource might have different processing requirement (ie, a different chaining of component) and of course a different targets.  This is where the wrapping is really resolved .  
		-->
		<!-- deegree processor send the query to a deegree mapping engine instead of a remote server -->

		<map:match pattern="wfs-process-GetFeature-deegree/*/*/*/*">
			<map:generate src="cocoon:/wfs-GetRequest/{1}/{4}"/>
				
					<!--<map:generate src="temp/req_d129.xml"/>-->
				<!-- transform the incoming request to a private request, according to the source -->
				<map:transform type="saxon" src="handler/{3}/in_{2}.xslt"/>
				<!-- this works with ArcIMS, wonder what harm it will do to wfs: query  - to be tested -->
				
				<!-- deegree transformer -->
				<map:transform type="DeegreeService"/>
				 <!--the result is fed to a out_handler that transform the result into a gsml document 
				<map:select type="resource-exists">
				<map:when test="handler/{3}/out_{2}.stx">
					<map:transform type="stx" src="handler/{3}/out_{2}.stx"/>
				</map:when>
				<map:otherwise>
					<map:transform type="saxon" src="handler/{3}/out_{2}.xslt"/>
				</map:otherwise>
				</map:select>-->
				<map:serialize type="xml"/>
			</map:match>
		<!-- 
GENERIC REMOTE GETFEATURE HANDLER 
This installation provides a  generic remote pipeline, it transforms the incoming request and POST it to
some remote server.  The location of the server is taken by matching the [source] = {3} with the global list at the top
invocation: wfs-process-GetFeature-[processor]/[key]/[handler]/[source]/[pos] that matches any processor. 

WARNING:  This processor should remain the last in the list because this one matches all possible processors therefore any processor listed after this one will never be matched
-->
			<map:match pattern="wfs-process-GetFeature-*/*/*/*/*">

			<map:generate src="cocoon:/wfs-GetRequest/{2}/{5}"/>
				
					<!--<map:generate src="temp/req_d129.xml"/>-->
				<!-- transform the incoming request to a private request, according to the source -->
				<map:transform type="saxon" src="handler/{4}/in_{3}.xslt"/>
				<!-- this works with ArcIMS, wonder what harm it will do to wfs: query  - to be tested -->
				<!--<map:transform type="saxon" src="style/removeNs.xslt"/>-->
				<!-- must add a transformer that loads the config, to get the address of the server, merge it with the query and have the stx to resolve it. then the next in line should remove the root nodes and leave only the result node -->
				
				<map:transform type="saxon" src="style/submit_wrapper.xslt">
					<map:parameter name="config" value="wfs-{session-attr:config}"/>
				</map:transform>
				<map:transform type="include"/>
				 <!-- send the request to the server -->
				 <map:transform type="stx" src="style/post.stx">
					 <map:parameter name="source" value="{4}"/>
				 </map:transform>
				<map:transform type="stx" src="style/extract_result.stx"/>
				<!-- 
				This is the previous method, now superceeded by the STX trick
					<map:transform type="PostClient">
					<map:parameter name="server" value="{global:url-{4}}"/>
				</map:transform>-->
				
				<!-- the result is fed to a out_handler that transform the result into a gsml document -->
				<map:select type="resource-exists">
				<map:when test="handler/{4}/out_{3}.stx">
					<map:transform type="stx" src="handler/{4}/out_{3}.stx"/>
				</map:when>
				<map:otherwise>
					<map:transform type="saxon" src="handler/{4}/out_{3}.xslt"/>
				</map:otherwise>
				</map:select>
				<map:serialize type="xml"/>

			</map:match>

</map:pipeline>

<map:pipeline>
	<map:match pattern="debug/post">
	<map:generate type="xmlStream"/>
	<map:serialize type="xml"/>
	</map:match>
</map:pipeline>

</map:pipelines>
</map:sitemap>